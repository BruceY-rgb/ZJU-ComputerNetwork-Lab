# Lab8 实验报告 - 第五、六部分

## 五、实验数据记录和处理

### 1. 服务器的主线程循环关键代码

**总体处理逻辑：**
主线程负责Socket初始化、监听端口、接受客户端连接，并为每个连接创建独立的处理线程。

```cpp
int main(int argc, char* argv[]) {
    // 1. 信号处理初始化
    signal(SIGINT, exitHandler);
    signal(SIGTERM, exitHandler);

    // 2. 创建并配置Socket
    int serverSocket = socket(AF_INET, SOCK_STREAM, 0);
    setsockopt(serverSocket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    // 3. 绑定地址和端口
    struct sockaddr_in serverAddress;
    serverAddress.sin_family = AF_INET;
    serverAddress.sin_addr.s_addr = INADDR_ANY;
    serverAddress.sin_port = htons(SERVER_PORT);  // 端口4703（学号后四位）
    bind(serverSocket, (struct sockaddr*)&serverAddress, sizeof(serverAddress));

    // 4. 开始监听
    listen(serverSocket, MAX_CLIENT_QUEUE);

    // 5. 主循环：接受连接并创建线程处理
    std::vector<std::thread> threads;
    while (!shouldExit) {
        // 等待并接受客户端连接
        int clientSocket = accept(serverSocket,
                                  (struct sockaddr*)&clientAddress,
                                  &clientAddressLength);

        // 获取客户端地址信息
        char clientIP[INET_ADDRSTRLEN];
        inet_ntop(AF_INET, &clientAddress.sin_addr, clientIP, INET_ADDRSTRLEN);
        std::string clientAddr = std::string(clientIP) + ":" +
                                std::to_string(ntohs(clientAddress.sin_port));

        // 创建新线程处理该客户端请求
        threads.emplace_back(handleClient, clientSocket, clientAddr);
        threads.back().detach();  // 分离线程，避免主线程阻塞
    }

    // 6. 清理资源并退出
    close(serverSocket);
    return 0;
}
```

**关键点说明：**
- 使用端口4703（学号后4位）
- `SO_REUSEADDR`选项允许端口快速重用
- 主循环中使用`accept()`阻塞等待客户端连接
- 每个连接创建独立线程处理，支持并发访问
- 使用`detach()`分离线程，让子线程独立运行

---

### 2. 服务器的客户端处理子线程关键代码

**总体处理逻辑：**
子线程负责接收HTTP请求、解析请求头、根据方法分发到GET/POST处理器、发送响应并关闭连接。

```cpp
void handleClient(int clientFd, std::string clientAddr) {
    // 1. 接收HTTP请求数据
    char buffer[8192] = {0};
    ssize_t byteRead = recv(clientFd, buffer, sizeof(buffer) - 1, 0);
    std::string rawRequest(buffer, byteRead);

    // 2. 解析请求行（方法、URI、HTTP版本）
    size_t firstCRLF = rawRequest.find("\r\n");
    std::string requestLine = rawRequest.substr(0, firstCRLF);

    size_t firstSpace = requestLine.find(' ');
    size_t secondSpace = requestLine.find(' ', firstSpace + 1);

    std::string method = requestLine.substr(0, firstSpace);
    std::string uri = requestLine.substr(firstSpace + 1, secondSpace - firstSpace - 1);
    std::string httpVersion = requestLine.substr(secondSpace + 1);

    // 3. 解析请求头（查找双CRLF标记头部结束）
    size_t headerEnd = rawRequest.find("\r\n\r\n");
    std::string headersStr = rawRequest.substr(firstCRLF + 2,
                                               headerEnd - (firstCRLF + 2));
    std::map<std::string, std::string> headers = parseHeaders(headersStr);

    // 4. 解析请求正文（如果有Content-Length）
    std::string requestBody;
    auto clIt = headers.find("content-length");
    if (clIt != headers.end()) {
        int contentLength = std::stoi(clIt->second);
        size_t bodyStart = headerEnd + 4;  // 跳过\r\n\r\n

        // 读取已接收的正文
        requestBody.append(buffer + bodyStart,
                          std::min((size_t)contentLength, byteRead - bodyStart));

        // 如果正文未完整接收，继续读取
        while (requestBody.length() < (size_t)contentLength) {
            char moreBuf[4096];
            ssize_t n = recv(clientFd, moreBuf,
                           std::min(sizeof(moreBuf),
                                   contentLength - requestBody.length()), 0);
            requestBody.append(moreBuf, n);
        }
    }

    // 5. 根据HTTP方法分发处理
    if (method == "GET") {
        getHandler(clientFd, uri, headers);
    } else if (method == "POST") {
        postHandler(clientFd, uri, headers, requestBody);
    } else {
        // 不支持的方法返回405
        HTTPResponse response(405, "Method Not Allowed");
        response.setHeader("Content-Type", "text/plain");
        response.setBody("");
        send(clientFd, response.serialize().c_str(), ...);
        close(clientFd);
    }
}
```

**GET请求处理逻辑：**
```cpp
void getHandler(int clientFd, const std::string uri,
                const std::map<std::string, std::string>& headers) {
    HTTPResponse response;

    // 1. URI映射到文件路径
    std::string filePath = mapUriToPath(uri);
    // 映射关系：
    // /index.html -> NetLabFramework/assets/html/test.html
    // /pic.jpg -> NetLabFramework/assets/img/logo.jpg
    // /info/server -> NetLabFramework/assets/txt/test.txt

    // 2. 检查文件是否存在
    if(filePath.empty() || !fileExists(filePath)) {
        response.setStatus(404, "Not Found");
        response.setHeader("Content-Type", "text/plain");
        response.setBody("");
    } else {
        // 3. 读取文件内容（支持二进制文件）
        std::string content = readFile(filePath);

        // 4. 设置响应
        response.setStatus(200, "OK");
        response.setHeader("Content-Type", getContentType(filePath));
        // Content-Type根据扩展名判断：
        // .html -> text/html
        // .txt -> text/plain
        // .jpg -> image/jpeg
        response.setBody(content);
    }

    // 5. 发送响应并关闭连接
    std::string responseStr = response.serialize();
    send(clientFd, responseStr.c_str(), responseStr.size(), 0);
    close(clientFd);
}
```

**POST请求处理逻辑：**
```cpp
void postHandler(int clientFd, const std::string uri,
                 const std::map<std::string, std::string>& headers,
                 const std::string& body) {
    HTTPResponse response;

    // 1. 检查URI是否为/dopost
    if(uri == "/dopost") {
        // 2. 解析表单数据（application/x-www-form-urlencoded格式）
        // 格式："login=3230104703&pass=ysx050223"
        std::map<std::string, std::string> formData = parsePostData(body);

        // 3. 获取用户名和密码
        std::string username = formData["login"];
        std::string password = formData["pass"];

        // 4. 验证登录信息
        std::string validUsername = "3230104703";  // 学号
        std::string validPassword = "ysx050223";   // 自定义密码

        std::string htmlBody;
        if (username == validUsername && password == validPassword) {
            htmlBody = "<html><body>Login Success</body></html>";
        } else {
            htmlBody = "<html><body>Login Failed</body></html>";
        }

        // 5. 设置响应
        response.setStatus(200, "OK");
        response.setHeader("Content-Type", "text/html");
        response.setBody(htmlBody);
    } else {
        // 不是/dopost，返回404
        response.setStatus(404, "Not Found");
        response.setHeader("Content-Type", "text/plain");
        response.setBody("");
    }

    // 6. 发送响应并关闭连接
    std::string responseStr = response.serialize();
    send(clientFd, responseStr.c_str(), responseStr.size(), 0);
    close(clientFd);
}
```

**关键点说明：**
- HTTP请求解析：通过查找`\r\n\r\n`定位头部结束
- 支持分段接收：如果正文未完整接收，循环读取直到满足Content-Length
- URI映射：将外部URL映射到内部文件路径，隐藏服务器目录结构
- 多线程安全：每个连接独立处理，使用mutex保护共享资源
- 自动设置Content-Length：在HTTPResponse类中自动计算正文长度

---

### 3. 服务器运行后监听端口

（此处应插入`netstat -an | grep 4703`的截图）

**说明：** 服务器监听在端口4703（学号后四位），状态为LISTEN。

---

### 4. 浏览器访问纯文本文件

**服务器上文件实际存放的路径：**
```
NetLabFramework/assets/txt/test.txt
```

**服务器的URI映射代码片段：**
```cpp
std::string mapUriToPath(const std::string& uri) {
    static std::map<std::string, std::string> UriMap = {
        {"/info/server", "NetLabFramework/assets/txt/test.txt"}
    };

    auto it = UriMap.find(uri);
    if(it != UriMap.end()) {
        return it->second;
    }
    return "";
}
```

**访问URL：** `http://127.0.0.1:4703/info/server`

（此处应插入浏览器显示截图和Wireshark截图）

---

### 5. 浏览器访问只包含文本的HTML文件

**服务器文件实际存放的路径：**
```
NetLabFramework/assets/html/noimg.html
```

**访问URL：** `http://127.0.0.1:4703/index_noimg.html`

（此处应插入Wireshark HTTP协议截图）

---

### 6. 浏览器访问包含文本、图片的HTML文件

**服务器上文件实际存放的路径：**
- HTML文件：`NetLabFramework/assets/html/test.html`
- 图片文件：`NetLabFramework/assets/img/logo.jpg`

**访问URL：** `http://127.0.0.1:4703/index.html`

**说明：** 浏览器首先请求HTML文件，解析后发现图片标签`<img src="/pic.jpg">`，自动发起第二次GET请求获取图片。

（此处应插入Wireshark截图，包含HTML和图片请求）

---

### 7. 登录功能测试

**服务器相关处理代码片段：**
```cpp
// 解析POST表单数据
std::map<std::string, std::string> parsePostData(const std::string& postData) {
    std::map<std::string, std::string> result;
    size_t pos = 0;

    while(pos < postData.size()) {
        size_t ampPos = postData.find("&", pos);
        if(ampPos == std::string::npos) ampPos = postData.size();

        std::string pair = postData.substr(pos, ampPos - pos);
        size_t equalPos = pair.find("=");

        if(equalPos != std::string::npos) {
            std::string key = pair.substr(0, equalPos);
            std::string value = pair.substr(equalPos + 1);
            result[key] = value;
        }
        pos = ampPos + 1;
    }
    return result;
}
```

**正确登录：**
- 用户名：3230104703
- 密码：ysx050223
- 显示：Login Success

**错误登录：**
- 显示：Login Failed

（此处应插入浏览器显示截图和Wireshark截图）

---

### 8. 多个浏览器同时访问测试

（此处应插入多个浏览器窗口截图和netstat输出截图）

**说明：** 服务器使用多线程模式，每个连接创建独立线程处理，支持并发访问。

---

## 六、实验结果与分析

### 1. HTTP协议是怎样对头部和体部进行分隔的？

**答：** HTTP协议使用**连续两个CRLF（`\r\n\r\n`）**来分隔头部和体部。

- 头部的每一行以CRLF（`\r\n`）结束
- 头部的最后一行后面紧跟一个额外的CRLF
- 因此头部和体部之间有连续的两个CRLF

**示例：**
```
GET /index.html HTTP/1.1\r\n
Host: 127.0.0.1:4703\r\n
Content-Length: 25\r\n
\r\n
login=admin&pass=12345
```

在代码中的体现：
```cpp
size_t headerEnd = rawRequest.find("\r\n\r\n");
size_t bodyStart = headerEnd + 4;  // 跳过\r\n\r\n这4个字符
```

---

### 2. 浏览器是根据文件的扩展名还是根据头部的哪个字段判断文件类型的？

**答：** 浏览器主要根据HTTP响应头部的**`Content-Type`字段**来判断文件类型，而不是文件的扩展名。

**原因：**
- 浏览器接收的是字节流，无法直接看到服务器上的文件扩展名
- URI路径可能不包含扩展名（如`/info/server`）
- `Content-Type`头部明确指示了内容的MIME类型

**常见的Content-Type值：**
- `text/html` - HTML文档
- `text/plain` - 纯文本
- `image/jpeg` - JPEG图片
- `image/png` - PNG图片
- `application/json` - JSON数据

**代码实现：**
```cpp
response.setHeader("Content-Type", getContentType(filePath));

// getContentType函数根据文件扩展名返回相应的MIME类型
std::string getContentType(const std::string& path) {
    std::string ext = toLower(path.substr(dotPos));
    if (ext == ".html") return "text/html";
    if (ext == ".txt") return "text/plain";
    if (ext == ".jpg") return "image/jpeg";
    // ...
}
```

---

### 3. HTTP协议的头部是不是一定是文本格式？体部呢？

**答：**

**头部：** 是的，HTTP协议的**头部一定是文本格式**（ASCII编码）。
- 所有的头部字段名和字段值都是可读的文本
- 以CRLF（`\r\n`）作为行分隔符
- 这保证了HTTP协议的可读性和调试便利性

**体部：** 不一定，HTTP协议的**体部可以是文本格式，也可以是二进制格式**。
- 文本格式：HTML、JSON、XML、纯文本等
- 二进制格式：图片（JPEG、PNG）、视频、音频、压缩文件等
- 体部的格式由头部的`Content-Type`字段指定

**代码体现：**
```cpp
// 读取文件时使用二进制模式，支持所有类型
std::ifstream file(path, std::ios::binary);

// 头部始终是文本
response += "HTTP/1.0 200 OK\r\n";
response += "Content-Type: image/jpeg\r\n";
response += "Content-Length: 45877\r\n";
response += "\r\n";

// 体部可以是二进制数据（图片字节）
response += binaryImageData;
```

---

### 4. POST方法传递的数据是放在头部还是体部？两个字段是用什么符号连接起来的？

**答：**

**数据位置：** POST方法传递的数据**放在体部（body）**，而不是头部。

**字段连接符号：**
- 多个字段之间使用**`&`符号**连接
- 字段名和字段值之间使用**`=`符号**连接
- 这种格式称为`application/x-www-form-urlencoded`

**示例：**
```
POST /dopost HTTP/1.1
Host: 127.0.0.1:4703
Content-Type: application/x-www-form-urlencoded
Content-Length: 34

login=3230104703&pass=ysx050223
```

**解析代码：**
```cpp
std::map<std::string, std::string> parsePostData(const std::string& postData) {
    std::map<std::string, std::string> result;
    size_t pos = 0;

    while(pos < postData.size()) {
        // 查找&符号，分隔不同字段
        size_t ampPos = postData.find("&", pos);
        std::string pair = postData.substr(pos, ampPos - pos);

        // 查找=符号，分隔字段名和值
        size_t equalPos = pair.find("=");
        std::string key = pair.substr(0, equalPos);
        std::string value = pair.substr(equalPos + 1);

        result[key] = value;
        pos = ampPos + 1;
    }
    return result;
}
```

**重要说明：**
- 体部长度由头部的`Content-Length`字段指定
- 服务器必须先读取`Content-Length`，才能知道需要接收多少字节的体部数据
- 字段值中的特殊字符会被URL编码（如空格变成`%20`）

---

**实验总结：**
本实验成功实现了一个轻量级的HTTP/1.0 Web服务器，支持GET和POST方法，能够正确处理文本、HTML和图片文件，支持多线程并发访问。通过实验深入理解了HTTP协议的结构、请求-响应机制以及多线程网络编程的实践。
